---
title: "Basics"
description: "Core syntax, variables, and types in Nebula."
---

# Basics

Everything you need to know to start writing Nebula code.

## Variables

### Declaration

```nebula
# Constant (immutable) - use perm
perm MAX_SIZE = 1000
perm APP_NAME = "MyApp"
perm PI = 3.14159

# Variable (mutable)
count = 0
count = count + 1

# Multiple declarations
x = 10
y = 20
z = x + y
```

### Naming Conventions

```nebula
# Variables: snake_case
user_count = 0
is_active = on

# Constants: UPPER_SNAKE_CASE
perm MAX_RETRIES = 5
perm API_URL = "https://api.example.com"

# Functions: snake_case
fn calculate_total() do ... end
fn get_user_by_id(id) do ... end
```

## Data Types

### Numbers

Nebula handles integers and floats automatically:

```nebula
# Integers
perm age = 25
perm year = 2024
perm negative = -100

# Floats
perm pi = 3.14159
perm price = 19.99
perm scientific = 1.5e10

# Operations
log(10 / 3)    # 3.333... (float division)
log(10 % 3)    # 1 (modulus)
log(2 ^ 10)    # 1024 (power)
```

### Booleans

Use `on` and `off` instead of true/false:

```nebula
perm is_active = on
perm is_deleted = off

if is_active do
    log("Active!")
end

# Logical operations
perm both = on and off     # off
perm either = on or off    # on
perm inverted = !on        # off
```

### Strings

Text enclosed in double quotes:

```nebula
perm greeting = "Hello, World!"
perm name = "Nebula"

# Concatenation
perm message = "Welcome to " + name
log(message)  # Welcome to Nebula

# String length
log(len("hello"))  # 5

# Accessing characters (0-indexed)
perm word = "hello"
log(word[0])  # h
log(word[4])  # o
```

### Empty (Null)

Use `empty` for absence of value:

```nebula
perm no_value = empty

if no_value == empty do
    log("Nothing here")
end

fn find(items, target) do
    each item in items do
        if item == target do
            give item
        end
    end
    give empty  # Not found
end
```

## Type Checking

Use `typeof()` to inspect types:

```nebula
log(typeof(42))        # "int"
log(typeof(3.14))      # "fl"
log(typeof("hello"))   # "wrd"
log(typeof(on))        # "bool"
log(typeof([1, 2]))    # "lst"
log(typeof({"a": 1}))  # "map"
log(typeof(empty))     # "nil"
```

### Type Reference

| Value | typeof Result | Description |
|-------|---------------|-------------|
| `42` | `int` | Integer |
| `3.14` | `fl` | Float |
| `"text"` | `wrd` | String |
| `on`/`off` | `bool` | Boolean |
| `[1,2,3]` | `lst` | List |
| `{"k":"v"}` | `map` | Map |
| `(1, 2)` | `tup` | Tuple |
| `empty` | `nil` | Null |
| `fn()=1` | `fn` | Function |

## Operators

### Arithmetic

| Operator | Description | Example | Result |
|----------|-------------|---------|--------|
| `+` | Addition | `5 + 3` | `8` |
| `-` | Subtraction | `5 - 3` | `2` |
| `*` | Multiplication | `5 * 3` | `15` |
| `/` | Division | `7 / 2` | `3.5` |
| `%` | Modulus | `7 % 3` | `1` |
| `^` | Power | `2 ^ 3` | `8` |
| `-` | Negation | `-5` | `-5` |

### Comparison

| Operator | Description | Example | Result |
|----------|-------------|---------|--------|
| `==` | Equal | `5 == 5` | `on` |
| `!=` | Not equal | `5 != 3` | `on` |
| `<` | Less than | `3 < 5` | `on` |
| `>` | Greater than | `5 > 3` | `on` |
| `<=` | Less or equal | `5 <= 5` | `on` |
| `>=` | Greater or equal | `5 >= 3` | `on` |

### Logical

| Operator | Description | Example | Result |
|----------|-------------|---------|--------|
| `and` | Logical AND | `on and off` | `off` |
| `or` | Logical OR | `on or off` | `on` |
| `!` | Logical NOT | `!on` | `off` |

### Bitwise

| Operator | Description | Example |
|----------|-------------|---------|
| `&` | AND | `5 & 3` → `1` |
| `\|` | OR | `5 \| 3` → `7` |
| `^|` | XOR | `5 ^| 3` → `6` |
| `~` | NOT | `~5` |
| `<<` | Left shift | `1 << 3` → `8` |
| `>>` | Right shift | `8 >> 2` → `2` |

### Compound Assignment

```nebula
x = 10
x += 5    # x = 15
x -= 3    # x = 12
x *= 2    # x = 24
x /= 4    # x = 6
```

## Comments

```nebula
# Single line comment

perm x = 10  # Inline comment

# Multi-line comments just use
# multiple single-line comments
# like this
```

## Expressions vs Statements

**Expressions** produce values:
```nebula
5 + 3           # 8
len("hello")    # 5
x > 10          # on or off
```

**Statements** perform actions:
```nebula
perm x = 10     # Variable declaration
log("hello")    # Function call
if x > 5 do ... end  # Control flow
```

## Scope

Variables are scoped to their block:

```nebula
perm global_var = "I'm global"

fn my_function() do
    perm local_var = "I'm local"
    log(global_var)  # OK - can access global
    log(local_var)   # OK - can access local
end

log(global_var)  # OK
# log(local_var)  # ERROR - not in scope
```
